# DGA Detector Primitive
> This is the DGA Detector Primitive created for the PRINCIPALS project. In this Primitive we want to monitor all the DNS lookups for the possibility of traffic from/to domains generated from an algorithm.


## Mirroring

This Primitive uses a mirroring of the whole nodes' networking traffic. For the mirroring to be realized you need to create a docker container. This container will use the image of Antrea as a base image because we want to have a Volume-mount with Antrea-Agent inside the K8s Cluster. Inside this file will be placed the script used for the appliance of the mirroring command to the bridge. This whole implementation can be found inside the mirroring directory(The Dockerfile needed for the container and the script needed for the mirroring).



## Installation
In order to install this Primitive inside your own Kubernetes Cluster, you should first create a Docker image that has all the necessary packages installed inside it. This can be done via the Dockerfile, using inside the directory that rests your Dockerfile alongside the necessary files, the command:

```Shell
docker build -t dgadtc .
```
Inside this container lies the monitor.py script that provides the necessary functionality for this primitive.

In order to deploy it to your own Kubernetes Cluster, you need to apply the yaml file. The yaml file contains an Init Container component for the mirroring to execute before the DGAdtc Pod is deployed. Before applying the yaml file provided, you should first change the image variable inside it to your own image's name(both the mirroring image and the dgadtc image). The command needed to apply the yaml file is:

```Shell
kubectl apply -f <yaml file>
```
where "yaml file" is the name of your yaml file. When deployed the Pod will have the whole nodes' traffic mirrored to its eth0 interface.

## Implementation

The necessary functionality for this Primitive is provided by the monitor.py script. This script uses the Scapy library in order to create a monitoring, with a filter of port 53, since the DNS request are the only thing we’re interested in.
Beside the sniffing that Scapy will provide, a class named DGA Detector is created, that takes a domain name and breaks it to a list of ints. Then, by using the appropriate padding, this list of ints is passed to the Keras model(dga.model). The Keras
module will return a prediction, a number between 0 and 1, that will be the possibility of this domain to be a domain generated by an algorithm. If the prediction
is higher than 0.5, we choose to deal with the domain as a domain generated by
an algorithm.
For every DNS request that is made in our node, our pod will get the domain name
and the IP of the requested domain and will check if it’s valid or not. If it’s not,
then through a TCP socket, our pod will communicate with the Flow-Server and
it will send him the IP of the domain alongside a blocking command.

It’s important to note, that since our first interface is used for the mirroring, the communication between our pod and the Flow-Server pod, is carried out through the secondary interface of those two pods. The secondary interface is
created with the use of Multus inside the yaml file.
